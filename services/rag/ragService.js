// services/rag/ragService.js
// Core RAG service with shared functionality

const logger = require('../../utils/logger');
const { classifyQuery } = require('./queryClassifier');
const { assembleContext } = require('./contextAssembler');
const { generateResponse } = require('./responseGenerator');

// Domain handlers
const wineHandler = require('./domains/wineHandler');
const visitingHandler = require('./domains/visitingHandler');
const clubHandler = require('./domains/clubHandler');
const merchandiseHandler = require('./domains/merchandiseHandler');
const generalHandler = require('./domains/generalHandler');
const wine_productionHandler = require('./domains/wine_productionHandler');
const loyaltyHandler = require('./domains/loyaltyHandler');

/**
 * Main entry point for RAG response generation
 * @param {string} query - User's query
 * @returns {Promise<Object>} - Generated response with sources
 */
async function generateRAGResponse(query) {
  try {
    logger.search(`Processing query: "${query}"`);
    
    // Step 1: Classify the query to determine the domain
    const queryInfo = classifyQuery(query);
    logger.info(`Query classified as: ${queryInfo.type} (subtype: ${queryInfo.subtype || 'none'})`);

    // Step 2: Retrieve context based on query classification
    const context = await assembleContext(query, queryInfo);
    logger.info(`Retrieved ${context.documents.length} relevant documents`);

    // Step 3: Handle the query with the appropriate domain handler
    let responseData;
    switch (queryInfo.type) {
      case 'wine':
        responseData = await wineHandler.handleQuery(query, queryInfo, context);
        break;
      case 'visiting':
        responseData = await visitingHandler.handleQuery(query, queryInfo, context);
        break;
      case 'club':
        responseData = await clubHandler.handleQuery(query, queryInfo, context);
        break;
      case 'merchandise':
        responseData = await merchandiseHandler.handleQuery(query, queryInfo, context);
        break;
      default:
        responseData = await generalHandler.handleQuery(query, queryInfo, context);
    }

    // Step 4: Generate the final response if not already generated by domain handler
    if (!responseData.response) {
      responseData = await generateResponse(query, queryInfo, context, responseData);
    }

    return {
      response: responseData.response,
      sources: responseData.sources || context.documents.map(doc => doc.metadata.source)
    };
  } catch (error) {
    logger.error('RAG Response Generation Error:', error);
    return { 
      response: "I apologize, but I'm having trouble generating a response right now.",
      sources: []
    };
  }
}

module.exports = {
  generateRAGResponse
};